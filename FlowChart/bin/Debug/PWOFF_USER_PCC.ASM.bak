
C_PWOFF_MODE EQU F0H
C_PWOFF_WAIT_MODE EQU F1H

;=======================================
PWOFF1_PRE1:


PWOFF1_STOP_PCC:

;====================================
;	MR_SET_MODE_NO C_MODE0_0

;.IFDEF C_LED_MATRIX_EN
;	JSR	BK0_MATRIX_LED_CTL_OFF
;.ENDIF

	JMP	L_ENTER_STOP


PWOFF1_WAITEQUSP:
	M_SET_MODE_NO C_PWOFF_WAIT_MODE
	MR_STOP_AUTOCNT
.IFDEF C_EQU0_EN
	MR_DET_EQU_BUSY
	BEQ	PWOFF1_WAITSP
;EQU
;	JMP	L_ENTER_STOP
	BRA	PWOFF1_CHKFG
.ENDIF
	
PWOFF1_WAITSP: ;WAIT SP / EQU
;
	MR_CHK_SPCH1_EN
	BRA	PWOFF1_CHKFG
	
PWOFF1:
	JSR WAITKEY
PWOFF1_CHKFG:
	M_CHK_SPCH1 PWOFF1_SPCH1
.IFDEF C_EQU0_EN
	M_CHK_EQU_NEXT PWOFF1_EQU_NEXT
.ENDIF
.IFDEF C_WIPER_EN
	M_CHK_WIPER_PATTEND PWOFF1_WIPER_PATTEND
.ENDIF
;	M_CHK_AUTOCNT PWOFF1_AUTOCNT
;	M_CHK_CASI PWOFF1_CASI;V31

	JMP	PWOFF1
	
PWOFF1_SPCH1:
;	M_CLR_SPCH1_FLAG
;-------------------------- no need delay @not specified	
;	MR_SET_AUTOCNT1
;	JMP	PWOFF1_CHKFG
	JMP	L_ENTER_STOP

.IFDEF C_EQU0_EN
PWOFF1_EQU_NEXT: ;EQU
	M_EQU_NEXT_JMP PWOFF1_EQU_NRL_NEXT,PWOFF1_EQU_NRL_NEXT
	JMP	PWOFF1_CHKFG
	
PWOFF1_EQU_NRL_NEXT:;EVT reach
	JSR	L_PLAY_EQU_NEXT
	BNE	PWOFF1_CH1END_EQU_NEXT
;EQU END
;-------------------------- no need delay 
;	MR_SET_AUTOCNT1
;	JMP	PWOFF1_CHKFG
	JMP	L_ENTER_STOP
PWOFF1_CH1END_EQU_NEXT:
	JMP	PWOFF1_CHKFG
.ENDIF ;C_EQU0_EN
	
.IFDEF C_WIPER_EN
PWOFF1_WIPER_PATTEND:
	M_CHK_EQU_WP1_PATTEND_EVT PWOFF1_EQU_NRL_NEXT,PWOFF1_CHKFG
	JMP	PWOFF1_CHKFG
.ENDIF

PWOFF1_AUTOCNT:

PWOFF1_AUTOCNT_PCC:
	JSR	BK0_AUTOCNT_DET_PWOFF;NOT check LVD
	BNE	PWOFF1_AUTOCNT_S10
;
.IFDEF C_WIPER_EN
	MR_DET_WP1_PATT_STOP
	BNE	PWOFF1_AUTOCNT_S10
.ENDIF

	JMP	L_ENTER_STOP

PWOFF1_AUTOCNT_S10:

	MR_SET_AUTOCNT1
	
	JMP	PWOFF1_CHKFG
	

;================================
L_ENTER_STOP:
	.IF ( C_DLYCNT0_ENABLE .EQ. 1 )
	M_SET_CNT0 CNT_STOP
	.ENDIF
	.IF ( C_DLYCNT1_ENABLE .EQ. 1 )
	M_SET_CNT1 CNT_STOP
	.ENDIF
	.IF ( C_DLYCNT2_ENABLE .EQ. 1 )
	M_SET_CNT2 CNT_STOP
	.ENDIF
	.IF ( C_DLYCNT3_ENABLE .EQ. 1 )
	M_SET_CNT3 CNT_STOP
	.ENDIF

;clear key debounce
;	M_SET_MODE_NO C_PWOFF_MODE
	
	JSR	BK0_ENTER_STOP_CLRKEY

ENTER_STOP1_PCC:

ENTER_STOP1_PCC_END:

;======================================================================================================================
.IF ( C_SPCH1_ENABLE	.EQ.	1 ) .OR. ( C_SPCH2_ENABLE	.EQ.	1 ).OR. ( C_SPCH3_ENABLE	.EQ.	1 ) .OR. ( C_MS1_ENABLE	.EQ.	1 ).OR. ( C_SPMD_ENABLE	.EQ.	1 ).OR. ( C_EVO1_ENABLE	.EQ.	1 )

	JSR BK0_STOP_ALL

.ENDIF
	
;	M_CLR_AUTOCNT_FLAG
;CMP_A
	.IFDEF C_CMPA_EN; N588HJ
	JSR	BK0_CMPAB_OFF

	.ENDIF
;stop HW PWM
.IFDEF  C_HWPWM_EN
	JSR	BK0_STOP_HWPWM
.ENDIF

;===============================
	
	
;================================================
ENTER_STOP2_PCC:

.IF (CHIPSERIES = 'N589A') .OR. (CHIPSERIES = 'N589B') .OR. (CHIPSERIES = 'N589C') .OR. (CHIPSERIES = 'N589D')
	LDO_OFF
.ENDIF

ENTER_STOP2_PCC_END:

;=================================================
;	M_CLOSE_SPK

.IF ( C_TMGX_EN .EQ. 1 )
	MR_TMGX_STOP
.ENDIF
.IF ( C_ULTRAIO_IO_EN .EQ. 1 )
	DIS_ULTRAIO_PIN 1
	DIS_ULTRAIO_PIN 2
	DIS_ULTRAIO_PIN 3	
.ENDIF
;----------------  SETTING wakeup source --------------
.IF (CHIPSERIES = 'N589A') .OR. (CHIPSERIES = 'N589B') .OR. (CHIPSERIES = 'N589C') .OR. (CHIPSERIES = 'N589D')
	
	.IF ( C_N589_TOUCH_EN .EQ. 1)
	JSR	PREPARE_FOR_CAP_SLEEP_SETTING ; in main.asm
		.IF ( C_POR_ENTER_STOP .EQ. 1 )
;delay > 50ms ; if
	JSR	BK0_DELAY50MS
	JSR	BK0_DELAY50MS
		.ENDIF
;-----------------------------------------
	.ELSE
		M_INT_DISABLE FXF15_INT_BIT
		MR_PWOFF_SET_IO
	.ENDIF
.ELSE
	M_INT_DISABLE FXF15_INT_BIT
	MR_PWOFF_SET_IO
.ENDIF


	MR_SET_PWOFF_FG

;if some IO change to input from output ;->;DELAY1MS

	JSR BK0_DELAY100US	

	JSR	BK0_STORE_BPX_WO_BOND_PWOFF
	MR_PWOFF_SET_WK

	
;-------------SPECIAL
.IF (CHIPSERIES = 'N589A') .OR. (CHIPSERIES = 'N589B') .OR. (CHIPSERIES = 'N589C') .OR. (CHIPSERIES = 'N589D')
;Store RAM to DPD_RAM
	M_RAM_BACKUP
	.IF ( C_N589_TOUCH_EN .EQ. 1)
	CAP_WAKEUP_ENABLE ; WITH 'STOP' command
	.ENDIF
.ENDIF
	
	M_WDT_CLR
	M_MCU_STOP
	
	NOP
	NOP
	NOP


;	M_INT_ENABLE FXF15_INT_BIT
	
;	M_SET_SPK
	
	LDA	#0E0H
WAKEUP_DELAY:
	INC	A
	BNE	WAKEUP_DELAY

	MR_SET_AUTOCNT1

	JMP	MAIN_WAKEUP



.if (CHIPSERIES = 'N589A') .OR. (CHIPSERIES = 'N589B') .OR. (CHIPSERIES = 'N589C') .OR. (CHIPSERIES = 'N589D')
;---------------------------
;--------------------------------------------------------------	
; // fill in the name of the RAMs needed to put into DPD RAM when sleep here //
S_DPD_TABLE:
;---------------------------
.IFDEF USER_FLAG20
	DW	USER_FLAG20
.ENDIF
	DW	SYS_MODE_NO
.IFDEF BP0_STATUS
	DW	BP0_STATUS
.ENDIF
.IFDEF BP1_STATUS
	DW	BP1_STATUS
.ENDIF
.IFDEF BP2_STATUS
	DW	BP2_STATUS
.ENDIF
.IFDEF USER_FLAG10
	DW	USER_FLAG10
.ENDIF
.IFDEF USER_INT_FLAG0
	DW	USER_INT_FLAG0
.ENDIF
.IFDEF USER_INT_CNT0
	DW	USER_INT_CNT0
.ENDIF
.IF ( C_N589_TOUCH_EN .EQ. 1)
	DW	TP_INT_FLAG0
.ENDIF

;--------------------------------
;





S_DPD_TABLE_END:
;----------------------------
C_DPD_TABLE_ADDRESS_TOTAL	EQU	(S_DPD_TABLE_END-S_DPD_TABLE)
C_DPD_TABLE_ELEMENT_TOTAL	EQU	(C_DPD_TABLE_ADDRESS_TOTAL/2)
  .if (C_DPD_TABLE_ELEMENT_TOTAL .GT. 32)
!!! ERROR !!!
; more than 32 bytes are needed to backup to DPD
  .endif


;--------------------------------------------------------------
; --- S_RAM_BACKUP ---
;--------------------------------------------------------------
S_RAM_BACKUP:
	LDX	#000				; RAM table pointer
	LDY	#000				; DPD pointer
S_RAM_BACKUP_LOOP:
	CPX	#C_DPD_TABLE_ADDRESS_TOTAL
	BCS	S_RAM_BACKUP_RETURN
	LDA	S_DPD_TABLE+00,X
	STA	<REG_EA+00
	LDA	S_DPD_TABLE+01,X
	STA	<REG_EA+01
	LDA	(<REG_EA+00)
	STA	R_DPD_RAM_START,Y
	INY
	INX
	INX
	BRA	S_RAM_BACKUP_LOOP
S_RAM_BACKUP_RETURN:
	RTS
;--------------------------------------------------------------
; --- S_RAM_RESTORE ---
;--------------------------------------------------------------
S_RAM_RESTORE:
	LDX	#000				; RAM table pointer
	LDY	#000				; DPD pointer
S_RAM_RESTORE_LOOP:
	CPX	#C_DPD_TABLE_ADDRESS_TOTAL
	BCS	S_RAM_RESTORE_RETURN
	LDA	S_DPD_TABLE+00,X
	STA	<REG_EA+00
	LDA	S_DPD_TABLE+01,X
	STA	<REG_EA+01
	LDA	R_DPD_RAM_START,Y
	STA	(<REG_EA+00)
	INY
	INX
	INX
	BRA	S_RAM_RESTORE_LOOP	
S_RAM_RESTORE_RETURN:
	RTS
.ENDIF
